{
  "version": 3,
  "sources": ["../../three/examples/jsm/utils/PackedPhongMaterial.js", "../../three/examples/jsm/utils/GeometryCompressionUtils.js"],
  "sourcesContent": ["\n/**\n * `PackedPhongMaterial` inherited from THREE.MeshPhongMaterial\n *\n * @param {Object} parameters\n */\nimport {\n\tMeshPhongMaterial,\n\tShaderChunk,\n\tShaderLib,\n\tUniformsUtils,\n} from 'three';\n\nclass PackedPhongMaterial extends MeshPhongMaterial {\n\n\tconstructor( parameters ) {\n\n\t\tsuper();\n\n\t\tthis.defines = {};\n\t\tthis.type = 'PackedPhongMaterial';\n\t\tthis.uniforms = UniformsUtils.merge( [\n\n\t\t\tShaderLib.phong.uniforms,\n\n\t\t\t{\n\t\t\t\tquantizeMatPos: { value: null },\n\t\t\t\tquantizeMatUV: { value: null }\n\t\t\t}\n\n\t\t] );\n\n\t\tthis.vertexShader = [\n\t\t\t'#define PHONG',\n\n\t\t\t'varying vec3 vViewPosition;',\n\n\t\t\tShaderChunk.common,\n\t\t\tShaderChunk.uv_pars_vertex,\n\t\t\tShaderChunk.displacementmap_pars_vertex,\n\t\t\tShaderChunk.envmap_pars_vertex,\n\t\t\tShaderChunk.color_pars_vertex,\n\t\t\tShaderChunk.fog_pars_vertex,\n\t\t\tShaderChunk.normal_pars_vertex,\n\t\t\tShaderChunk.morphtarget_pars_vertex,\n\t\t\tShaderChunk.skinning_pars_vertex,\n\t\t\tShaderChunk.shadowmap_pars_vertex,\n\t\t\tShaderChunk.logdepthbuf_pars_vertex,\n\t\t\tShaderChunk.clipping_planes_pars_vertex,\n\n\t\t\t`#ifdef USE_PACKED_NORMAL\n\t\t\t\t\t#if USE_PACKED_NORMAL == 0\n\t\t\t\t\t\tvec3 decodeNormal(vec3 packedNormal)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tfloat x = packedNormal.x * 2.0 - 1.0;\n\t\t\t\t\t\t\tfloat y = packedNormal.y * 2.0 - 1.0;\n\t\t\t\t\t\t\tvec2 scth = vec2(sin(x * PI), cos(x * PI));\n\t\t\t\t\t\t\tvec2 scphi = vec2(sqrt(1.0 - y * y), y);\n\t\t\t\t\t\t\treturn normalize( vec3(scth.y * scphi.x, scth.x * scphi.x, scphi.y) );\n\t\t\t\t\t\t}\n\t\t\t\t\t#endif\n\n\t\t\t\t\t#if USE_PACKED_NORMAL == 1\n\t\t\t\t\t\tvec3 decodeNormal(vec3 packedNormal)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tvec3 v = vec3(packedNormal.xy, 1.0 - abs(packedNormal.x) - abs(packedNormal.y));\n\t\t\t\t\t\t\tif (v.z < 0.0)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tv.xy = (1.0 - abs(v.yx)) * vec2((v.x >= 0.0) ? +1.0 : -1.0, (v.y >= 0.0) ? +1.0 : -1.0);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\treturn normalize(v);\n\t\t\t\t\t\t}\n\t\t\t\t\t#endif\n\n\t\t\t\t\t#if USE_PACKED_NORMAL == 2\n\t\t\t\t\t\tvec3 decodeNormal(vec3 packedNormal)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tvec3 v = (packedNormal * 2.0) - 1.0;\n\t\t\t\t\t\t\treturn normalize(v);\n\t\t\t\t\t\t}\n\t\t\t\t\t#endif\n\t\t\t\t#endif`,\n\n\t\t\t`#ifdef USE_PACKED_POSITION\n\t\t\t\t\t#if USE_PACKED_POSITION == 0\n\t\t\t\t\t\tuniform mat4 quantizeMatPos;\n\t\t\t\t\t#endif\n\t\t\t\t#endif`,\n\n\t\t\t`#ifdef USE_PACKED_UV\n\t\t\t\t\t#if USE_PACKED_UV == 1\n\t\t\t\t\t\tuniform mat3 quantizeMatUV;\n\t\t\t\t\t#endif\n\t\t\t\t#endif`,\n\n\t\t\t`#ifdef USE_PACKED_UV\n\t\t\t\t\t#if USE_PACKED_UV == 0\n\t\t\t\t\t\tvec2 decodeUV(vec2 packedUV)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tvec2 uv = (packedUV * 2.0) - 1.0;\n\t\t\t\t\t\t\treturn uv;\n\t\t\t\t\t\t}\n\t\t\t\t\t#endif\n\n\t\t\t\t\t#if USE_PACKED_UV == 1\n\t\t\t\t\t\tvec2 decodeUV(vec2 packedUV)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tvec2 uv = ( vec3(packedUV, 1.0) * quantizeMatUV ).xy;\n\t\t\t\t\t\t\treturn uv;\n\t\t\t\t\t\t}\n\t\t\t\t\t#endif\n\t\t\t\t#endif`,\n\n\t\t\t'void main() {',\n\n\t\t\tShaderChunk.uv_vertex,\n\n\t\t\t`#ifdef USE_MAP\n\t\t\t\t\t#ifdef USE_PACKED_UV\n\t\t\t\t\t\tvMapUv = decodeUV(vMapUv);\n\t\t\t\t\t#endif\n\t\t\t\t#endif`,\n\n\t\t\tShaderChunk.color_vertex,\n\t\t\tShaderChunk.morphcolor_vertex,\n\n\t\t\tShaderChunk.beginnormal_vertex,\n\n\t\t\t`#ifdef USE_PACKED_NORMAL\n\t\t\t\t\tobjectNormal = decodeNormal(objectNormal);\n\t\t\t\t#endif\n\n\t\t\t\t#ifdef USE_TANGENT\n\t\t\t\t\tvec3 objectTangent = vec3( tangent.xyz );\n\t\t\t\t#endif\n\t\t\t\t`,\n\n\t\t\tShaderChunk.morphnormal_vertex,\n\t\t\tShaderChunk.skinbase_vertex,\n\t\t\tShaderChunk.skinnormal_vertex,\n\t\t\tShaderChunk.defaultnormal_vertex,\n\t\t\tShaderChunk.normal_vertex,\n\n\t\t\tShaderChunk.begin_vertex,\n\n\t\t\t`#ifdef USE_PACKED_POSITION\n\t\t\t\t\t#if USE_PACKED_POSITION == 0\n\t\t\t\t\t\ttransformed = ( vec4(transformed, 1.0) * quantizeMatPos ).xyz;\n\t\t\t\t\t#endif\n\t\t\t\t#endif`,\n\n\t\t\tShaderChunk.morphtarget_vertex,\n\t\t\tShaderChunk.skinning_vertex,\n\t\t\tShaderChunk.displacementmap_vertex,\n\t\t\tShaderChunk.project_vertex,\n\t\t\tShaderChunk.logdepthbuf_vertex,\n\t\t\tShaderChunk.clipping_planes_vertex,\n\n\t\t\t'vViewPosition = - mvPosition.xyz;',\n\n\t\t\tShaderChunk.worldpos_vertex,\n\t\t\tShaderChunk.envmap_vertex,\n\t\t\tShaderChunk.shadowmap_vertex,\n\t\t\tShaderChunk.fog_vertex,\n\n\t\t\t'}',\n\t\t].join( '\\n' );\n\n\t\t// Use the original MeshPhongMaterial's fragmentShader.\n\t\tthis.fragmentShader = ShaderLib.phong.fragmentShader;\n\n\t\tthis.setValues( parameters );\n\n\t}\n\n}\n\nexport { PackedPhongMaterial };\n", "/**\n * Octahedron and Quantization encodings based on work by:\n *\n * @link https://github.com/tsherif/mesh-quantization-example\n *\n */\n\nimport {\n\tBufferAttribute,\n\tMatrix3,\n\tMatrix4,\n\tVector3\n} from 'three';\nimport { PackedPhongMaterial } from './PackedPhongMaterial.js';\n\n\n\n/**\n * Make the input mesh.geometry's normal attribute encoded and compressed by 3 different methods.\n * Also will change the mesh.material to `PackedPhongMaterial` which let the vertex shader program decode the normal data.\n *\n * @param {THREE.Mesh} mesh\n * @param {String} encodeMethod\t\t\"DEFAULT\" || \"OCT1Byte\" || \"OCT2Byte\" || \"ANGLES\"\n *\n */\nfunction compressNormals( mesh, encodeMethod ) {\n\n\tif ( ! mesh.geometry ) {\n\n\t\tconsole.error( 'Mesh must contain geometry. ' );\n\n\t}\n\n\tconst normal = mesh.geometry.attributes.normal;\n\n\tif ( ! normal ) {\n\n\t\tconsole.error( 'Geometry must contain normal attribute. ' );\n\n\t}\n\n\tif ( normal.isPacked ) return;\n\n\tif ( normal.itemSize != 3 ) {\n\n\t\tconsole.error( 'normal.itemSize is not 3, which cannot be encoded. ' );\n\n\t}\n\n\tconst array = normal.array;\n\tconst count = normal.count;\n\n\tlet result;\n\tif ( encodeMethod == 'DEFAULT' ) {\n\n\t\t// TODO: Add 1 byte to the result, making the encoded length to be 4 bytes.\n\t\tresult = new Uint8Array( count * 3 );\n\n\t\tfor ( let idx = 0; idx < array.length; idx += 3 ) {\n\n\t\t\tconst encoded = defaultEncode( array[ idx ], array[ idx + 1 ], array[ idx + 2 ], 1 );\n\n\t\t\tresult[ idx + 0 ] = encoded[ 0 ];\n\t\t\tresult[ idx + 1 ] = encoded[ 1 ];\n\t\t\tresult[ idx + 2 ] = encoded[ 2 ];\n\n\t\t}\n\n\t\tmesh.geometry.setAttribute( 'normal', new BufferAttribute( result, 3, true ) );\n\t\tmesh.geometry.attributes.normal.bytes = result.length * 1;\n\n\t} else if ( encodeMethod == 'OCT1Byte' ) {\n\n\t\t/**\n\t\t* It is not recommended to use 1-byte octahedron normals encoding unless you want to extremely reduce the memory usage\n\t\t* As it makes vertex data not aligned to a 4 byte boundary which may harm some WebGL implementations and sometimes the normal distortion is visible\n\t\t* Please refer to @zeux 's comments in https://github.com/mrdoob/three.js/pull/18208\n\t\t*/\n\n\t\tresult = new Int8Array( count * 2 );\n\n\t\tfor ( let idx = 0; idx < array.length; idx += 3 ) {\n\n\t\t\tconst encoded = octEncodeBest( array[ idx ], array[ idx + 1 ], array[ idx + 2 ], 1 );\n\n\t\t\tresult[ idx / 3 * 2 + 0 ] = encoded[ 0 ];\n\t\t\tresult[ idx / 3 * 2 + 1 ] = encoded[ 1 ];\n\n\t\t}\n\n\t\tmesh.geometry.setAttribute( 'normal', new BufferAttribute( result, 2, true ) );\n\t\tmesh.geometry.attributes.normal.bytes = result.length * 1;\n\n\t} else if ( encodeMethod == 'OCT2Byte' ) {\n\n\t\tresult = new Int16Array( count * 2 );\n\n\t\tfor ( let idx = 0; idx < array.length; idx += 3 ) {\n\n\t\t\tconst encoded = octEncodeBest( array[ idx ], array[ idx + 1 ], array[ idx + 2 ], 2 );\n\n\t\t\tresult[ idx / 3 * 2 + 0 ] = encoded[ 0 ];\n\t\t\tresult[ idx / 3 * 2 + 1 ] = encoded[ 1 ];\n\n\t\t}\n\n\t\tmesh.geometry.setAttribute( 'normal', new BufferAttribute( result, 2, true ) );\n\t\tmesh.geometry.attributes.normal.bytes = result.length * 2;\n\n\t} else if ( encodeMethod == 'ANGLES' ) {\n\n\t\tresult = new Uint16Array( count * 2 );\n\n\t\tfor ( let idx = 0; idx < array.length; idx += 3 ) {\n\n\t\t\tconst encoded = anglesEncode( array[ idx ], array[ idx + 1 ], array[ idx + 2 ] );\n\n\t\t\tresult[ idx / 3 * 2 + 0 ] = encoded[ 0 ];\n\t\t\tresult[ idx / 3 * 2 + 1 ] = encoded[ 1 ];\n\n\t\t}\n\n\t\tmesh.geometry.setAttribute( 'normal', new BufferAttribute( result, 2, true ) );\n\t\tmesh.geometry.attributes.normal.bytes = result.length * 2;\n\n\t} else {\n\n\t\tconsole.error( 'Unrecognized encoding method, should be `DEFAULT` or `ANGLES` or `OCT`. ' );\n\n\t}\n\n\tmesh.geometry.attributes.normal.needsUpdate = true;\n\tmesh.geometry.attributes.normal.isPacked = true;\n\tmesh.geometry.attributes.normal.packingMethod = encodeMethod;\n\n\t// modify material\n\tif ( ! ( mesh.material instanceof PackedPhongMaterial ) ) {\n\n\t\tmesh.material = new PackedPhongMaterial().copy( mesh.material );\n\n\t}\n\n\tif ( encodeMethod == 'ANGLES' ) {\n\n\t\tmesh.material.defines.USE_PACKED_NORMAL = 0;\n\n\t}\n\n\tif ( encodeMethod == 'OCT1Byte' ) {\n\n\t\tmesh.material.defines.USE_PACKED_NORMAL = 1;\n\n\t}\n\n\tif ( encodeMethod == 'OCT2Byte' ) {\n\n\t\tmesh.material.defines.USE_PACKED_NORMAL = 1;\n\n\t}\n\n\tif ( encodeMethod == 'DEFAULT' ) {\n\n\t\tmesh.material.defines.USE_PACKED_NORMAL = 2;\n\n\t}\n\n}\n\n\n/**\n\t * Make the input mesh.geometry's position attribute encoded and compressed.\n\t * Also will change the mesh.material to `PackedPhongMaterial` which let the vertex shader program decode the position data.\n\t *\n\t * @param {THREE.Mesh} mesh\n\t *\n\t */\nfunction compressPositions( mesh ) {\n\n\tif ( ! mesh.geometry ) {\n\n\t\tconsole.error( 'Mesh must contain geometry. ' );\n\n\t}\n\n\tconst position = mesh.geometry.attributes.position;\n\n\tif ( ! position ) {\n\n\t\tconsole.error( 'Geometry must contain position attribute. ' );\n\n\t}\n\n\tif ( position.isPacked ) return;\n\n\tif ( position.itemSize != 3 ) {\n\n\t\tconsole.error( 'position.itemSize is not 3, which cannot be packed. ' );\n\n\t}\n\n\tconst array = position.array;\n\tconst encodingBytes = 2;\n\n\tconst result = quantizedEncode( array, encodingBytes );\n\n\tconst quantized = result.quantized;\n\tconst decodeMat = result.decodeMat;\n\n\t// IMPORTANT: calculate original geometry bounding info first, before updating packed positions\n\tif ( mesh.geometry.boundingBox == null ) mesh.geometry.computeBoundingBox();\n\tif ( mesh.geometry.boundingSphere == null ) mesh.geometry.computeBoundingSphere();\n\n\tmesh.geometry.setAttribute( 'position', new BufferAttribute( quantized, 3 ) );\n\tmesh.geometry.attributes.position.isPacked = true;\n\tmesh.geometry.attributes.position.needsUpdate = true;\n\tmesh.geometry.attributes.position.bytes = quantized.length * encodingBytes;\n\n\t// modify material\n\tif ( ! ( mesh.material instanceof PackedPhongMaterial ) ) {\n\n\t\tmesh.material = new PackedPhongMaterial().copy( mesh.material );\n\n\t}\n\n\tmesh.material.defines.USE_PACKED_POSITION = 0;\n\n\tmesh.material.uniforms.quantizeMatPos.value = decodeMat;\n\tmesh.material.uniforms.quantizeMatPos.needsUpdate = true;\n\n}\n\n/**\n * Make the input mesh.geometry's uv attribute encoded and compressed.\n * Also will change the mesh.material to `PackedPhongMaterial` which let the vertex shader program decode the uv data.\n *\n * @param {THREE.Mesh} mesh\n *\n */\nfunction compressUvs( mesh ) {\n\n\tif ( ! mesh.geometry ) {\n\n\t\tconsole.error( 'Mesh must contain geometry property. ' );\n\n\t}\n\n\tconst uvs = mesh.geometry.attributes.uv;\n\n\tif ( ! uvs ) {\n\n\t\tconsole.error( 'Geometry must contain uv attribute. ' );\n\n\t}\n\n\tif ( uvs.isPacked ) return;\n\n\tconst range = { min: Infinity, max: - Infinity };\n\n\tconst array = uvs.array;\n\n\tfor ( let i = 0; i < array.length; i ++ ) {\n\n\t\trange.min = Math.min( range.min, array[ i ] );\n\t\trange.max = Math.max( range.max, array[ i ] );\n\n\t}\n\n\tlet result;\n\n\tif ( range.min >= - 1.0 && range.max <= 1.0 ) {\n\n\t\t// use default encoding method\n\t\tresult = new Uint16Array( array.length );\n\n\t\tfor ( let i = 0; i < array.length; i += 2 ) {\n\n\t\t\tconst encoded = defaultEncode( array[ i ], array[ i + 1 ], 0, 2 );\n\n\t\t\tresult[ i ] = encoded[ 0 ];\n\t\t\tresult[ i + 1 ] = encoded[ 1 ];\n\n\t\t}\n\n\t\tmesh.geometry.setAttribute( 'uv', new BufferAttribute( result, 2, true ) );\n\t\tmesh.geometry.attributes.uv.isPacked = true;\n\t\tmesh.geometry.attributes.uv.needsUpdate = true;\n\t\tmesh.geometry.attributes.uv.bytes = result.length * 2;\n\n\t\tif ( ! ( mesh.material instanceof PackedPhongMaterial ) ) {\n\n\t\t\tmesh.material = new PackedPhongMaterial().copy( mesh.material );\n\n\t\t}\n\n\t\tmesh.material.defines.USE_PACKED_UV = 0;\n\n\t} else {\n\n\t\t// use quantized encoding method\n\t\tresult = quantizedEncodeUV( array, 2 );\n\n\t\tmesh.geometry.setAttribute( 'uv', new BufferAttribute( result.quantized, 2 ) );\n\t\tmesh.geometry.attributes.uv.isPacked = true;\n\t\tmesh.geometry.attributes.uv.needsUpdate = true;\n\t\tmesh.geometry.attributes.uv.bytes = result.quantized.length * 2;\n\n\t\tif ( ! ( mesh.material instanceof PackedPhongMaterial ) ) {\n\n\t\t\tmesh.material = new PackedPhongMaterial().copy( mesh.material );\n\n\t\t}\n\n\t\tmesh.material.defines.USE_PACKED_UV = 1;\n\n\t\tmesh.material.uniforms.quantizeMatUV.value = result.decodeMat;\n\t\tmesh.material.uniforms.quantizeMatUV.needsUpdate = true;\n\n\t}\n\n}\n\n\n// Encoding functions\n\nfunction defaultEncode( x, y, z, bytes ) {\n\n\tif ( bytes == 1 ) {\n\n\t\tconst tmpx = Math.round( ( x + 1 ) * 0.5 * 255 );\n\t\tconst tmpy = Math.round( ( y + 1 ) * 0.5 * 255 );\n\t\tconst tmpz = Math.round( ( z + 1 ) * 0.5 * 255 );\n\t\treturn new Uint8Array( [ tmpx, tmpy, tmpz ] );\n\n\t} else if ( bytes == 2 ) {\n\n\t\tconst tmpx = Math.round( ( x + 1 ) * 0.5 * 65535 );\n\t\tconst tmpy = Math.round( ( y + 1 ) * 0.5 * 65535 );\n\t\tconst tmpz = Math.round( ( z + 1 ) * 0.5 * 65535 );\n\t\treturn new Uint16Array( [ tmpx, tmpy, tmpz ] );\n\n\t} else {\n\n\t\tconsole.error( 'number of bytes must be 1 or 2' );\n\n\t}\n\n}\n\n// for `Angles` encoding\nfunction anglesEncode( x, y, z ) {\n\n\tconst normal0 = parseInt( 0.5 * ( 1.0 + Math.atan2( y, x ) / Math.PI ) * 65535 );\n\tconst normal1 = parseInt( 0.5 * ( 1.0 + z ) * 65535 );\n\treturn new Uint16Array( [ normal0, normal1 ] );\n\n}\n\n// for `Octahedron` encoding\nfunction octEncodeBest( x, y, z, bytes ) {\n\n\tlet oct, dec, best, currentCos, bestCos;\n\n\t// Test various combinations of ceil and floor\n\t// to minimize rounding errors\n\tbest = oct = octEncodeVec3( x, y, z, 'floor', 'floor' );\n\tdec = octDecodeVec2( oct );\n\tbestCos = dot( x, y, z, dec );\n\n\toct = octEncodeVec3( x, y, z, 'ceil', 'floor' );\n\tdec = octDecodeVec2( oct );\n\tcurrentCos = dot( x, y, z, dec );\n\n\tif ( currentCos > bestCos ) {\n\n\t\tbest = oct;\n\t\tbestCos = currentCos;\n\n\t}\n\n\toct = octEncodeVec3( x, y, z, 'floor', 'ceil' );\n\tdec = octDecodeVec2( oct );\n\tcurrentCos = dot( x, y, z, dec );\n\n\tif ( currentCos > bestCos ) {\n\n\t\tbest = oct;\n\t\tbestCos = currentCos;\n\n\t}\n\n\toct = octEncodeVec3( x, y, z, 'ceil', 'ceil' );\n\tdec = octDecodeVec2( oct );\n\tcurrentCos = dot( x, y, z, dec );\n\n\tif ( currentCos > bestCos ) {\n\n\t\tbest = oct;\n\n\t}\n\n\treturn best;\n\n\tfunction octEncodeVec3( x0, y0, z0, xfunc, yfunc ) {\n\n\t\tlet x = x0 / ( Math.abs( x0 ) + Math.abs( y0 ) + Math.abs( z0 ) );\n\t\tlet y = y0 / ( Math.abs( x0 ) + Math.abs( y0 ) + Math.abs( z0 ) );\n\n\t\tif ( z < 0 ) {\n\n\t\t\tconst tempx = ( 1 - Math.abs( y ) ) * ( x >= 0 ? 1 : - 1 );\n\t\t\tconst tempy = ( 1 - Math.abs( x ) ) * ( y >= 0 ? 1 : - 1 );\n\n\t\t\tx = tempx;\n\t\t\ty = tempy;\n\n\t\t\tlet diff = 1 - Math.abs( x ) - Math.abs( y );\n\t\t\tif ( diff > 0 ) {\n\n\t\t\t\tdiff += 0.001;\n\t\t\t\tx += x > 0 ? diff / 2 : - diff / 2;\n\t\t\t\ty += y > 0 ? diff / 2 : - diff / 2;\n\n\t\t\t}\n\n\t\t}\n\n\t\tif ( bytes == 1 ) {\n\n\t\t\treturn new Int8Array( [\n\t\t\t\tMath[ xfunc ]( x * 127.5 + ( x < 0 ? 1 : 0 ) ),\n\t\t\t\tMath[ yfunc ]( y * 127.5 + ( y < 0 ? 1 : 0 ) )\n\t\t\t] );\n\n\t\t}\n\n\t\tif ( bytes == 2 ) {\n\n\t\t\treturn new Int16Array( [\n\t\t\t\tMath[ xfunc ]( x * 32767.5 + ( x < 0 ? 1 : 0 ) ),\n\t\t\t\tMath[ yfunc ]( y * 32767.5 + ( y < 0 ? 1 : 0 ) )\n\t\t\t] );\n\n\t\t}\n\n\n\t}\n\n\tfunction octDecodeVec2( oct ) {\n\n\t\tlet x = oct[ 0 ];\n\t\tlet y = oct[ 1 ];\n\n\t\tif ( bytes == 1 ) {\n\n\t\t\tx /= x < 0 ? 127 : 128;\n\t\t\ty /= y < 0 ? 127 : 128;\n\n\t\t} else if ( bytes == 2 ) {\n\n\t\t\tx /= x < 0 ? 32767 : 32768;\n\t\t\ty /= y < 0 ? 32767 : 32768;\n\n\t\t}\n\n\n\t\tconst z = 1 - Math.abs( x ) - Math.abs( y );\n\n\t\tif ( z < 0 ) {\n\n\t\t\tconst tmpx = x;\n\t\t\tx = ( 1 - Math.abs( y ) ) * ( x >= 0 ? 1 : - 1 );\n\t\t\ty = ( 1 - Math.abs( tmpx ) ) * ( y >= 0 ? 1 : - 1 );\n\n\t\t}\n\n\t\tconst length = Math.sqrt( x * x + y * y + z * z );\n\n\t\treturn [\n\t\t\tx / length,\n\t\t\ty / length,\n\t\t\tz / length\n\t\t];\n\n\t}\n\n\tfunction dot( x, y, z, vec3 ) {\n\n\t\treturn x * vec3[ 0 ] + y * vec3[ 1 ] + z * vec3[ 2 ];\n\n\t}\n\n}\n\nfunction quantizedEncode( array, bytes ) {\n\n\tlet quantized, segments;\n\n\tif ( bytes == 1 ) {\n\n\t\tquantized = new Uint8Array( array.length );\n\t\tsegments = 255;\n\n\t} else if ( bytes == 2 ) {\n\n\t\tquantized = new Uint16Array( array.length );\n\t\tsegments = 65535;\n\n\t} else {\n\n\t\tconsole.error( 'number of bytes error! ' );\n\n\t}\n\n\tconst decodeMat = new Matrix4();\n\n\tconst min = new Float32Array( 3 );\n\tconst max = new Float32Array( 3 );\n\n\tmin[ 0 ] = min[ 1 ] = min[ 2 ] = Number.MAX_VALUE;\n\tmax[ 0 ] = max[ 1 ] = max[ 2 ] = - Number.MAX_VALUE;\n\n\tfor ( let i = 0; i < array.length; i += 3 ) {\n\n\t\tmin[ 0 ] = Math.min( min[ 0 ], array[ i + 0 ] );\n\t\tmin[ 1 ] = Math.min( min[ 1 ], array[ i + 1 ] );\n\t\tmin[ 2 ] = Math.min( min[ 2 ], array[ i + 2 ] );\n\t\tmax[ 0 ] = Math.max( max[ 0 ], array[ i + 0 ] );\n\t\tmax[ 1 ] = Math.max( max[ 1 ], array[ i + 1 ] );\n\t\tmax[ 2 ] = Math.max( max[ 2 ], array[ i + 2 ] );\n\n\t}\n\n\tdecodeMat.scale( new Vector3(\n\t\t( max[ 0 ] - min[ 0 ] ) / segments,\n\t\t( max[ 1 ] - min[ 1 ] ) / segments,\n\t\t( max[ 2 ] - min[ 2 ] ) / segments\n\t) );\n\n\tdecodeMat.elements[ 12 ] = min[ 0 ];\n\tdecodeMat.elements[ 13 ] = min[ 1 ];\n\tdecodeMat.elements[ 14 ] = min[ 2 ];\n\n\tdecodeMat.transpose();\n\n\n\tconst multiplier = new Float32Array( [\n\t\tmax[ 0 ] !== min[ 0 ] ? segments / ( max[ 0 ] - min[ 0 ] ) : 0,\n\t\tmax[ 1 ] !== min[ 1 ] ? segments / ( max[ 1 ] - min[ 1 ] ) : 0,\n\t\tmax[ 2 ] !== min[ 2 ] ? segments / ( max[ 2 ] - min[ 2 ] ) : 0\n\t] );\n\n\tfor ( let i = 0; i < array.length; i += 3 ) {\n\n\t\tquantized[ i + 0 ] = Math.floor( ( array[ i + 0 ] - min[ 0 ] ) * multiplier[ 0 ] );\n\t\tquantized[ i + 1 ] = Math.floor( ( array[ i + 1 ] - min[ 1 ] ) * multiplier[ 1 ] );\n\t\tquantized[ i + 2 ] = Math.floor( ( array[ i + 2 ] - min[ 2 ] ) * multiplier[ 2 ] );\n\n\t}\n\n\treturn {\n\t\tquantized: quantized,\n\t\tdecodeMat: decodeMat\n\t};\n\n}\n\nfunction quantizedEncodeUV( array, bytes ) {\n\n\tlet quantized, segments;\n\n\tif ( bytes == 1 ) {\n\n\t\tquantized = new Uint8Array( array.length );\n\t\tsegments = 255;\n\n\t} else if ( bytes == 2 ) {\n\n\t\tquantized = new Uint16Array( array.length );\n\t\tsegments = 65535;\n\n\t} else {\n\n\t\tconsole.error( 'number of bytes error! ' );\n\n\t}\n\n\tconst decodeMat = new Matrix3();\n\n\tconst min = new Float32Array( 2 );\n\tconst max = new Float32Array( 2 );\n\n\tmin[ 0 ] = min[ 1 ] = Number.MAX_VALUE;\n\tmax[ 0 ] = max[ 1 ] = - Number.MAX_VALUE;\n\n\tfor ( let i = 0; i < array.length; i += 2 ) {\n\n\t\tmin[ 0 ] = Math.min( min[ 0 ], array[ i + 0 ] );\n\t\tmin[ 1 ] = Math.min( min[ 1 ], array[ i + 1 ] );\n\t\tmax[ 0 ] = Math.max( max[ 0 ], array[ i + 0 ] );\n\t\tmax[ 1 ] = Math.max( max[ 1 ], array[ i + 1 ] );\n\n\t}\n\n\tdecodeMat.scale(\n\t\t( max[ 0 ] - min[ 0 ] ) / segments,\n\t\t( max[ 1 ] - min[ 1 ] ) / segments\n\t);\n\n\tdecodeMat.elements[ 6 ] = min[ 0 ];\n\tdecodeMat.elements[ 7 ] = min[ 1 ];\n\n\tdecodeMat.transpose();\n\n\tconst multiplier = new Float32Array( [\n\t\tmax[ 0 ] !== min[ 0 ] ? segments / ( max[ 0 ] - min[ 0 ] ) : 0,\n\t\tmax[ 1 ] !== min[ 1 ] ? segments / ( max[ 1 ] - min[ 1 ] ) : 0\n\t] );\n\n\tfor ( let i = 0; i < array.length; i += 2 ) {\n\n\t\tquantized[ i + 0 ] = Math.floor( ( array[ i + 0 ] - min[ 0 ] ) * multiplier[ 0 ] );\n\t\tquantized[ i + 1 ] = Math.floor( ( array[ i + 1 ] - min[ 1 ] ) * multiplier[ 1 ] );\n\n\t}\n\n\treturn {\n\t\tquantized: quantized,\n\t\tdecodeMat: decodeMat\n\t};\n\n}\n\n\n\nexport {\n\tcompressNormals,\n\tcompressPositions,\n\tcompressUvs,\n};\n"],
  "mappings": "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",
  "names": ["x", "y", "oct", "z"]
}
